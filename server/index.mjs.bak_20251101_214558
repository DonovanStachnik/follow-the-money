import express from "express";
import cors from "cors";
import fetch from "node-fetch";

const app = express();
app.use(cors());
app.use(express.json());
app.use(express.static("public"));

function hasOptions(chain) {
  return Array.isArray(chain) && chain.some(x => (x?.options?.CALL?.length || x?.options?.PUT?.length));
}

/** FINNHUB: returns [{ expirationDate: 'YYYY-MM-DD', options: { CALL:[], PUT:[] }}, ...] */
async function getFinnhubChain(symbol) {
  const token = process.env.FINNHUB_API_KEY;
  if (!token) return [];
  const url = new URL("https://finnhub.io/api/v1/stock/option-chain");
  url.searchParams.set("symbol", symbol);
  url.searchParams.set("token", token);
  const r = await fetch(url, { timeout: 15000 });
  if (!r.ok) throw new Error(\Finnhub \\);
  const j = await r.json();
  return Array.isArray(j?.data) ? j.data : [];
}

/** YAHOO: returns same shape as above for up to 4 expiries */
async function getYahooChain(symbol) {
  const base = \https://query2.finance.yahoo.com/v7/finance/options/\\;
  const hdrs = { "user-agent": "Mozilla/5.0" };

  const r0 = await fetch(base, { timeout: 15000, headers: hdrs });
  if (!r0.ok) throw new Error(\Yahoo \\);
  const j0 = await r0.json();
  const res0 = j0?.optionChain?.result?.[0];
  if (!res0) return [];

  const dates = res0.expirationDates || [];
  const pick = dates.slice(0, 4); // take a few expiries
  const out = [];

  for (const d of pick) {
    const u = new URL(base);
    u.searchParams.set("date", String(d));
    const r = await fetch(u, { timeout: 15000, headers: hdrs });
    if (!r.ok) continue;
    const jj = await r.json();
    const res = jj?.optionChain?.result?.[0];
    const opt = res?.options?.[0];
    if (!opt) continue;

    const calls = (opt.calls || []).map(o => ({
      strike: o.strike, volume: o.volume, openInterest: o.openInterest,
      lastPrice: o.lastPrice, bid: o.bid, ask: o.ask, impliedVolatility: o.impliedVolatility
    }));
    const puts = (opt.puts || []).map(o => ({
      strike: o.strike, volume: o.volume, openInterest: o.openInterest,
      lastPrice: o.lastPrice, bid: o.bid, ask: o.ask, impliedVolatility: o.impliedVolatility
    }));

    out.push({
      expirationDate: new Date(d * 1000).toISOString().slice(0, 10),
      options: { CALL: calls, PUT: puts }
    });
  }
  return out;
}

/** Try Finnhub then Yahoo */
async function getChain(symbol) {
  try {
    const fh = await getFinnhubChain(symbol);
    if (hasOptions(fh)) return fh;
  } catch (e) {
    console.warn("Finnhub failed:", e.message || e);
  }
  const yh = await getYahooChain(symbol);
  return yh;
}

app.get("/api/health", (_req, res) => {
  res.json({ ok: true, ts: new Date().toISOString() });
});

app.get("/api/search", async (req, res) => {
  try {
    const symbol = String(req.query.ticker || req.query.symbol || "").toUpperCase();
    if (!symbol) return res.status(400).json({ error: "ticker required" });
    const chain = await getChain(symbol);
    const expirations = chain.map(x => x.expirationDate).filter(Boolean);
    res.json({ symbol, expirations });
  } catch (e) {
    res.status(500).json({ error: "search failed", detail: String(e?.message || e) });
  }
});

app.get("/api/flow2", async (req, res) => {
  try {
    const symbol = String(req.query.ticker || req.query.symbol || "").toUpperCase();
    const date = String(req.query.date || "").trim();
    const limit = Math.max(1, Math.min(200, Number(req.query.limit) || 25));
    if (!symbol) return res.status(400).json({ error: "ticker required" });

    const chain = await getChain(symbol);
    let exp = chain.find(x => x.expirationDate === date);
    if (!exp) {
      exp = chain[0];
    }
    if (!exp) return res.json({ symbol, date: date || null, count: 0, items: [] });

    const items = [];
    const pushSide = (arr, side) => {
      for (const o of (arr || [])) {
        const volume = Number(o.volume || 0);
        const oi     = Number(o.openInterest || 0);
        const last   = Number(o.lastPrice || 0);
        const bid    = Number(o.bid || 0);
        const ask    = Number(o.ask || 0);
        const mid    = (bid > 0 && ask > 0) ? (bid + ask) / 2 : 0;
        const px     = last > 0 ? last : mid;
        const strike = Number(o.strike || 0);
        const prem   = Math.round(px * volume * 100);
        const iv     = Number(o.impliedVolatility || 0);
        if (prem > 0) items.push({ side, strike, volume, oi, bid, ask, last, iv, premium: prem });
      }
    };
    pushSide(exp.options?.CALL, "CALL");
    pushSide(exp.options?.PUT,  "PUT");

    items.sort((a,b) => b.premium - a.premium);
    res.json({ symbol, date: exp.expirationDate || date || null, count: items.length, items: items.slice(0, limit) });
  } catch (e) {
    res.status(500).json({ error: "flow2 failed", detail: String(e?.message || e) });
  }
});

app.get("/api/grid2", async (req, res) => {
  try {
    const symbol = String(req.query.ticker || req.query.symbol || "").toUpperCase();
    const rows = Math.max(5, Math.min(50, Number(req.query.rows) || 12));
    const cols = Math.max(1, Math.min(6, Number(req.query.cols) || 4));
    if (!symbol) return res.status(400).json({ error: "ticker required" });

    const chain = await getChain(symbol);
    const pick = chain.slice(0, cols);
    const expirations = pick.map(x => x.expirationDate);

    // Build net premium per strike (CALL prem - PUT prem)
    const byExp = pick.map(exp => {
      const map = new Map();
      const add = (o, sign) => {
        const strike = Number(o.strike || 0);
        const vol = Number(o.volume || 0);
        const last = Number(o.lastPrice || 0);
        const bid  = Number(o.bid || 0);
        const ask  = Number(o.ask || 0);
        const px   = last > 0 ? last : ((bid > 0 && ask > 0) ? (bid + ask) / 2 : 0);
        const prem = px * vol * 100 * sign;
        map.set(strike, (map.get(strike) || 0) + prem);
      };
      for (const c of (exp.options?.CALL || [])) add(c, +1);
      for (const p of (exp.options?.PUT  || [])) add(p, -1);
      // Top strikes by absolute premium
      const arr = Array.from(map.entries()).map(([strike, value]) => ({ strike, value: Math.round(value) }));
      arr.sort((a,b) => Math.abs(b.value) - Math.abs(a.value));
      return arr.slice(0, rows);
    });

    res.json({ symbol, expirations, columns: byExp });
  } catch (e) {
    res.status(500).json({ error: "grid2 failed", detail: String(e?.message || e) });
  }
});

const PORT = process.env.PORT || 3000;
app.listen(PORT, () => console.log(\API listening on http://localhost:\\));
